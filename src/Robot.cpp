// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include <math.h>
#include "Commands/AutoCrab.h"
#include "Commands/Blue_Auto40kPa.h"
#include "Commands/AutoGear.h"
#include "Commands/AutoGearAngle.h"
#include "Commands/Blue_Auto40kPaGear.h"
#include "Commands/Red_AutoGearAngle.h"
#include "Commands/Red_Auto40kPaGear.h"
#include "Commands/AutoGear5Pt.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Intake> Robot::intake;
//std::shared_ptr<Drive> Robot::drive;
std::shared_ptr<Gear> Robot::gear;
std::shared_ptr<Climb> Robot::climb;
std::shared_ptr<CompressorSubsystem> Robot::compressorSubsystem;
std::shared_ptr<Shooter> Robot::shooter;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<DrivePID> Robot::drivePID;
//std::shared_ptr<ShooterPID> Robot::shooterPID;
//std::shared_ptr<AHRS>Robot::m_gyro;

void Robot::RobotInit() {
	RobotMap::init();


	if (NULL == m_gyro){
				std::cout << "-------------------------- NULL" << std::cout;
	}


	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	std::cout << "------ 1 " << std::endl;
    intake.reset(new Intake());
	std::cout << "------ 2 " << std::endl;
//    drive.reset(new Drive());
    gear.reset(new Gear());
	std::cout << "------ 3 " << std::endl;
    climb.reset(new Climb());
	std::cout << "------ 4 " << std::endl;
    compressorSubsystem.reset(new CompressorSubsystem());
	std::cout << "------ 5 " << std::endl;
    shooter.reset(new Shooter());
	std::cout << "------ 6 " << std::endl;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());
	std::cout << "------ 7 " << std::endl;
	drivePID.reset(new DrivePID());
	std::cout << "------ 8 " << std::endl;
	//shooterPID.reset(new ShooterPID());

	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

	m_gyro = new AHRS(SPI::Port::kMXP);
	autonomousCommand.reset(new AutoGear5Pt());

//	m_gyro = new AHRS(SPI::kMXP);

	std::cout << "------ 9 " << std::endl;
	drivePID->SetGyroPointer(m_gyro);
	m_gyro->ZeroYaw();

//	if (NULL == m_gyro){
//				std::cout << "-------------------------- NULL" << std::cout;
//			}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	//m_gyro = RobotMap::m_gyro;
	std::cout << "------ 10 " << std::endl;
//	m_gyro.reset(new AHRS((SPI::Port::kMXP)));
	//RobotMap::m_gyro = new AHRS(SPI::Port::kMXP);// Alternatives:  SPI::kMXP, I2C::kMXP or SerialPort::kUSB

	SmartDashboard::init();

//	m_alliance = new SendableChooser();
//	m_autoMode = new SendableChooser();

//	m_alliance->AddDefault("Default to Red", new /*command*/);
//	m_alliance->AddObject("Red Alliance", new /*command*/);
//	m_alliance->AddObject("Blue Alliance", new /*command*/);
//	SmartDashboard::PutData("Alliance Colors!", m_alliance);

//	m_autoMode->AddDefault("Default to Center Gear", new AutoGear());

//
//
//	m_autoMode->AddDefault("Default to Center Gear", new AutoGear());
//	m_autoMode->AddObject("Center Gear", new AutoGear());
//	m_autoMode->AddObject("Left Angle Gear", new AutoGearAngle());
//	m_autoMode->AddObject("Right Angle Gear", new AutoGearAngle());
//	m_autoMode->AddObject("Blue Gear + 40kPa", new Blue_Auto40kPaGear());
//	m_autoMode->AddObject("Blue 40kPa", new Blue_Auto40kPa());
////	m_autoMode->AddObject("Red Gear + 40kPa", new Red_Auto40kPaGear());
////	m_autoMode->AddObject("Red 40kPa", new Red_Auto40kPa());
//	SmartDashboard::PutData("Auto Modes", m_autoMode);

  }

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	compressorSubsystem->StopCompressor();
	intake->StopIntake();
	//drivePID->ResetEncoders();
}

void Robot::DisabledPeriodic() {

//	std::cout << "Yaw: " << m_gyro->GetYaw() << " Pitch: " << m_gyro->GetPitch()
//			<< " Roll: " << m_gyro->GetRoll()<< " Is Connected? " << (m_gyro->IsConnected() ? "Yes" : "No")
//			<< " Firmware: " << m_gyro->GetFirmwareVersion() << std::endl;

std::cout << " --------------------------- before get yaw" << std::endl;

	std::cout << "Yaw: " << drivePID->GetYaw() << std::endl;
	//std::cout << drivePID->GetRightEncoder() << " " << drivePID->GetLeftEncoder() << " " << drivePID->GetHEncoder() << std::endl;
	std::cout << " ------------------ after get yaw ----------------" << std::endl;

	Scheduler::GetInstance()->Run();
//	shooter->PrintShooterRPM();


 //drivePID->PrintPIDs();
//	std::cout /*<< " Distance travelled: " << drivePID->GetDistanceTraveled() */<< "  H encoder: " << RobotMap::driveHEncoder->Get()
//			<< " Left encoder: "<< RobotMap::driveLeftEncoder->Get() << " Right encoder: " <<RobotMap::driveRightEncoder->Get()
//			<< " Talon H encoder: " << RobotMap::driveHLeft->GetEncPosition() << " Talon Left encoder: " << RobotMap::driveIntakeLeft->GetEncPosition()
//			<< " Talon Right encoder: " << RobotMap::driveIntakeRight->GetEncPosition() << " Encoder velocity TEST: "
//			<< RobotMap::driveIntakeRight->GetEncVel() << " " << RobotMap::driveIntakeLeft->GetEncVel() << " "
//			<< RobotMap::driveHLeft->GetEncVel() << " Shooter Encoder: " << RobotMap::shooterShooterRight->GetEncVel() <<  " "
//			<< RobotMap::shooterShooterRight->GetEncPosition() << std::endl ;
//
//	double pValue = oi.get()->getTuningJoystick1()->GetRawAxis(4);
//	double iValue = oi.get()->getTuningJoystick1()->GetRawAxis(2);
//	double dValue = oi.get()->getTuningJoystick1()->GetRawAxis(3);
//
//	if(pValue >= 0 || iValue >= 0 || dValue >= 0){
//			shooter->SetPIDValues(pValue, iValue, dValue);
//			std::cout << "P: " << pValue << "  I: " << iValue << "  D: " << dValue << " " /*<< std::endl*/ << " Actual P: " <<
//							RobotMap::shooterShooterRight->GetP() << " Actual I: " << RobotMap::shooterShooterRight->GetI() << " Actual D: " <<
//							RobotMap::shooterShooterRight->GetD();
//			shooter->PrintShooterRPM();
//			//shooter->UpdateSecondary();
//		}

	//	std::cout << "Intake " << intake->IsFuelDetectorTripped() << std::endl;

//		drivePID->GetLeftEncoder();
//		drivePID->GetRightEncoder();
//		drivePID->GetHEncoder();
		//shooter->PrintShooterRPM();
	//std::cout << " ------------------ after get instance ----------------" << std::endl;
	compressorSubsystem->StopCompressor();
	std::cout << " ------------------ end of disabled periodic ----------------" << std::endl;
}

void Robot::AutonomousInit() {
	if (autonomousCommand.get() != nullptr){
		std::cout << "Autonomous Init ---------------------------------------" << std::endl;
		autonomousCommand->Start();
	}
	drivePID->ResetEncoders();
	compressorSubsystem->StartCompressor();
}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();


	compressorSubsystem->StartCompressor();

	//CameraServer::GetInstance()->SetSize(CameraServer::kSize640x480);
//	cs::UsbCamera camera = CameraServer::GetInstance()->StartAutomaticCapture();
//	const cs::VideoSource source = cs::VideoSource::kUsb;
//	cs::UsbCamera camera = CameraServer::GetInstance()->AddCamera(source);
//	camera.SetResolution(640, 480);
	//CameraServer::GetInstance()->StartAutomaticCapture();

	m_incrementPressed = false;
	m_decrementPressed = false;
	m_stopPressed = false;
	m_rpmSet = 0;

	//drivePID->SetDirection(0);
}

void Robot::TeleopPeriodic() {
//////////////////////////////////////////////////////////


	Scheduler::GetInstance()->Run();

	//drivePID->DriveStraight(.6);	//RobotMap::shooterShooterRight->Reset();
	//drivePID->SetSidePower(0, -.4, -1, false);

//	drivePID->SetHPower(-1);
//	drivePID->ArcadeDrive(0, -.325);

	//RobotMap::driveHLeft->Set(.8);
	//double rpmTest = oi->getOperatorJoystick()->GetRawAxis(0); //l/r on right axis

	//Shoot
	if(oi->getOperatorJoystick()->GetRawAxis(2) > .15){ //x
	shooter->SetShooterSpeed(1100);
	//shooter->BangBang();
	shooter->UpdateSecondary();
	shooter->SetPIDValues(8, 0, 80);
	}
	else{
//		shooter->DisablePID();
		//shooter->SetShooterSpeed(0);
		shooter->KillShooterSpeed();
	//	std::cout << "Shooter Speed"
//		shooter->UpdateSecondary();

	}

//	std::cout << " Is Connected? " << (RobotMap::m_gyro->IsConnected() ? "Yes" : "No")
//				<< " Firmware: " << RobotMap::m_gyro->GetFirmwareVersion() << std::endl;



//
	if(oi->getOperatorJoystick()->GetRawButton(1))
	{
		shooter->StartFeeder();
	}
	else if(oi->getOperatorJoystick()->GetRawAxis(5)>.25){
		RobotMap::shooterFeeder->Set(oi->getOperatorJoystick()->GetRawAxis(5));
	}
	else{ //a
		shooter->StopFeeder();
		//intake->StartIntake();
	}

	//Intake
//	std::cout<< " Intake Right: " << RobotMap::intakeIntakeRight->Get() << " Intake Left: " << RobotMap::intakeIntakeLeft << std::endl;
	//intake->StartIntake();
	if((oi->getDriverJoystick()->GetRawAxis(2) > 0.5) || oi->getOperatorJoystick()->GetRawButton(1) || (oi->getOperatorJoystick()->GetRawAxis(3) > .5)){ //sets m_userOverride
		intake->SetUserOveride(true);
//			RobotMap::intakeIntakeRight->Set(-.8);
//			RobotMap::intakeIntakeLeft->Set(.8);
	//	intake->RunIntakeWithSensor();
	}
	else if(oi->getDriverJoystick()->GetRawButton(1)){
			intake->SetReverse(true);
	}
	else
	{
		intake->SetUserOveride(false);
		intake->SetReverse(false);
	}
	intake->StartIntake();
	std::cout << "Intake command: run" << std::endl;

//	else if (oi->getDriverJoystick()->GetRawButton(1)){ // a
//		//intake->StopIntake();
//	}
//	else if(oi->getOperatorJoystick()->GetRawButton(1)){
//		RobotMap::intakeIntakeRight->Set(-.8);
//					RobotMap::intakeIntakeLeft->Set(.8);
//	}
//	else if(oi->getDriverJoystick()->GetRawButton(1)){
//		RobotMap::intakeIntakeRight->Set(.8);
//					RobotMap::intakeIntakeLeft->Set(-.8);
//	}
//	else{
//		intake->StopIntake();
//		//intake->RunIntakeWithSensor();
//	}
//	std::cout << "Intake Sensor: " << intake->IsFuelDetectorTripped() << std::endl;
//
//	//Shooter
//	if(oi->getOperatorJoystick()->GetRawAxis(2)){
//		shooter->SetShooterSpeed(2000);
//	}
//	else{
//		shooter->SetShooterSpeed(0);
//	}
//
//
//	std::cout << "Yaw: " << RobotMap::m_gyro->GetYaw() << " Pitch: " << RobotMap::m_gyro->GetPitch()
//			<< " Roll: " << RobotMap::m_gyro->GetRoll()<< " Is Connected? " << (RobotMap::m_gyro->IsConnected() ? "Yes" : "No")
//			<< " Firmware: " << RobotMap::m_gyro->GetFirmwareVersion() << std::endl;

//

//	RobotMap::driveHLeft->Set(.8);
//	RobotMap::driveIntakeLeft->Set(.8);
//	RobotMap::driveHopperLeft->Set(0.8);
//	RobotMap::driveIntakeRight->Set(1.0);
//	RobotMap::driveHRight->Set(1.0);
//	RobotMap::driveHopperRight->Set(1.0);
//	RobotMap::driveRobotDrive41->TankDrive(1.0, 1.0);
//	//Drive
	double move = oi->getDriverJoystick()->GetRawAxis(1);
	double 	turn = oi->getDriverJoystick()->GetRawAxis(4);
	double roll = oi->getDriverJoystick()->GetRawAxis(0);

	if(fabs(move) < .15){
		move = 0;
	}


	if(fabs(roll) < .15){
		roll = 0;
	}

	if(fabs(turn) < .15){
		turn = 0;
	}

	bool reverseDirection= oi->getDriverJoystick()->GetRawButton(6);
	drivePID->SetSidePower(move, turn, roll, reverseDirection);
	std::cout << "Set Side Power: success!" << std::endl;

//	if(oi->getOperatorJoystick()->GetRawButton(1)) {// a
//		climb->debugClimb(1.0);
////		std::cout << "Intake: " << RobotMap::intakeIntakeMotor << std::endl;
//	}
//	else{
//		climb->debugClimb(0.0);
//	}
//
////	std::cout<<"H Left: " << RobotMap::driveHLeft->Get() << "  H Right: " << RobotMap::driveHRight->Get() << "  Hopper Left: "
////			<< RobotMap::driveHopperLeft << "  Hopper Right: " << RobotMap::driveHopperRight << "  Intake Left: " << RobotMap::driveIntakeLeft
////			<< "  Intake Right: " << RobotMap::driveIntakeRight->Get() << "  Right Encoder: " << drivePID->GetRightEncoder()
////			<< "  Left Encoder: " << drivePID->GetLeftEncoder() << "  H Encoder: " << drivePID->GetHEncoder() << std:: endl;
//


	//Tune shooter PID
//	double pValue = oi.get()->getTuningJoystick1()->GetRawAxis(4) * 100;
//	double iValue = oi.get()->getTuningJoystick1()->GetRawAxis(2) * 100;
//	double dValue = oi.get()->getTuningJoystick1()->GetRawAxis(3) * 100;
//
//	if(pValue >= 0 || iValue >= 0 || dValue >= 0){
//		//drivePID->SetPIDs(pValue, iValue, dValue);
//		//shooter->SetPIDValues(pValue, iValue, dValue);
		//std::cout << "P: " << pValue << "  I: " << iValue << "  D: " << dValue << " " /*<< std::endl*/ <<
//			std::cout <<	" Actual P: " <<
//				RobotMap::shooterShooterRight->GetP() << " Actual I: " << RobotMap::shooterShooterRight->GetI() << " Actual D: " <<
//				RobotMap::shooterShooterRight->GetD() << std::endl;
//	 shooter->PrintShooterRPM();
//		//shooter->UpdateSecondary();
//	}
////	drivePID->DriveStraight(.5);
//
//
//	//Testing Pnuematics
//	gear->OperateEjector(oi->getOperatorJoystick()->GetRawButton(5)); //Left Bumper
//	gear->OperatePlate(oi->getOperatorJoystick()->GetRawButton(6)); //Right Bumper
//	climb->ReleaseClimber(oi->getOperatorJoystick()->GetRawButton(7)); //Back
//	if(oi->getOperatorJoystick()->GetRawButton(8)) //Start
//	{
//		drivePID->DeployFeet();
//	}
//	else
//	{
//		drivePID->RetractFeet();
//	}
//
//
//	//Set shooter RPM
//
////	if(oi->getOperatorJoystick()->GetRawButton(2)){
////		shooter->SetShooterSpeed(200);
////	}
////	else{
////		shooter->SetShooterSpeed(0);
////	}
////	if(oi->getOperatorJoystick()->GetRawButton(2)) { //'B'
////		m_incrementPressed = true;
////	}
////	if(oi->getOperatorJoystick()->GetRawButton(1)) { //'A'
////		m_decrementPressed = true;
////	}
////	if(oi->getOperatorJoystick()->GetRawButton(8)) { //'Start'
////		m_stopPressed = true;
////	}
////
////	int changeValue = 50;
////	if(!(oi->getOperatorJoystick()->GetRawButton(2)) && m_incrementPressed) {
////		if(0 == m_rpmSet) { //motor isn't running yet
////			m_rpmSet = 200;
////		}
////		else
////		{
////			m_rpmSet += changeValue;
////		}
////		shooter->SetShooterSpeed(m_rpmSet);
////	}
////	if(!(oi->getOperatorJoystick()->GetRawButton(1)) && m_decrementPressed) {
////		if(m_rpmSet < changeValue) { //don't reverse the motor
////			m_rpmSet = 0;
////		}
////		else
////		{
////			m_rpmSet -= changeValue;
////		}
////		shooter->SetShooterSpeed(m_rpmSet);
////	}
////	if(!(oi->getOperatorJoystick()->GetRawButton(8)) && m_stopPressed) {
////		m_rpmSet = 0;
////
////	}
//	//shooter->SetShooterSpeed(m_rpmSet);
//	//shooter->PrintShooterRPM();
//
	Wait(0.005); //seconds
	std::cout << "End of Teleop periodic" << std::endl;
}

void Robot::TestPeriodic() {
	lw->Run();

	std::cout<<"ClimbDetectorForward : "<<RobotMap::climbClimbDetectorForward<<std::endl;

	std::cout<<"ClimbDetectorBack :"<<RobotMap::climbClimbDetectorBack<<std::endl;

	std::cout<<"FuelDetector :"<<RobotMap::intakeFuelDetector<<std::endl;
}


START_ROBOT_CLASS(Robot);


